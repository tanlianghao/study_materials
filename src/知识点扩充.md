## 知识点扩充

### 2020-05-20

1.正则表达式的纵向匹配 [png|jpg]表示匹配[]内的某一个字符
2.webpack打包css之后，服务端渲染css报语法错误。（为什么）
3.nodemon 使用方式 npm-run-all一次性执行多条命名
4.高阶组件的使用
5.node进程、线程及父子进程之间的通信方式
单进程单线程，为了使用多核多来的好处，node可以使用child_process来fork子进程。父子进程的通信方式有很多
比如通过socket、ipc通道、消息机制。父子进程怎么监听同一个端口。当客户端连接上服务端的时候，父进程会主动
建立一个客户端-服务端的socket通道，并把该通道的文件描述符下发给所有的子进程。同时父进程不在监听该端口。

### 2020-05-21

1、react SSR渲染出现闪屏现象，原因是服务端生成的dom同客户端生成的dom不一致，导致客户端重新渲染一次，导致这一现象的原因：异步/延迟加载、存在随机属性、环境不同。浏览器的document有些元素不能在服务端渲染。
2、浏览器的EventLoop机制： 栈、堆、消息队列；事件的回调优先于异步函数回调；浏览器的线程划分：GUI渲染引擎线程、js引擎线程、事件执行线程、定时器执行线程、异步http请求线程。
3、Node.js的EventLoop机制：在执行宏任务跟微任务是都是一队执行，跟浏览器宏任务的执行有所不同。node线程划分：timer ---> io --->idea空闲 ---> polling ---> check ---> socket close。
4、promise 如果是需要捕获错误，最好是使用catch来捕获，而不要写在then的第二个参数上。如果是promise错误未被捕获，在浏览器中是不会冒泡到外层，代码执行不会停止，而在node.js中存在着unhandleRejection事件来专门捕获rejected错误。finally方法返回值的判断。
5、async函数返回的是promise对象，自身的执行更多的像是promise.all方法的调用，状态的改变需要等await代码全部执行完，如果是有一个状态变成rejected，之后的await代码不再执行。

### 2020-05-23

1、promise的使用范围。遇到的问题：工具库返回了promise，不过是通过bable编译过的，在另外一个老项目中运行的，是否能够直接使用promise上的方法属性，比如then。结果貌似是可以直接调用。then方法更多的是它原型上的方法属性，bable转化成es5的类组成结构。
2、浏览器报错问题，只会阻止对应线程上的代码后续运行。比如下面这种情况。<img src="/Users/tanlianghao/Library/Application Support/typora-user-images/image-20200523183452120.png" alt="image-20200523183452120" style="zoom:50%;" />

运行结果：111 --> JSON.parse报错信息 ---> 333。

```javascript
console.log(111)
```

代码是运行在主线程上，所以就算上面的代码JSON.parse报错也不会影响后续的代码执行。

```javascript
console.log(333)
```

也是异步调用，代码是执行在浏览器的异步http请求线程上。
3、瀑布流布局，通过js计算高度，如果是通过clientHeight来计算，在一些浏览器会出现块状空白的情况，这种问题可以采用item的getBoundingclientrect方法来获取元素高度。

### 2020-05-25

1、react中setState源码分析；

![image-20200525173618341](/Users/tanlianghao/Library/Application Support/typora-user-images/image-20200525173618341.png)

整个流程中需要⚠️的点，isBatchingUpdates状态很重要，另外react合成事件，生命周期函数都可以改变值。另外transaction对象中封装了在执行主函数前后需要被执行的函数。通过transaction.perform方法来启动对象。
3、在react的合成事件中，事件对象event是被公用，在对应的事件处理函数执行完之后会被清空，并且如果事件处理函数中有异步代码导致主线程上的代码运行完之后event被清空，会导致异步代码中拿不到event对象。

### 2020-05-26

1、在使用react useState hook时，该函数不会把新的state跟旧的state合并。这点在给原来的值增加新值时需要⚠️。
2、自定义的hook中，如果该hooks被其他组件多次调用，自定义hook中的state值不共用。
3、⚠️在使用axios调用ajax接口时候，出现后端拿不到参数。查询资料发现是axios在post请求的时候默认

```javascript
Content-Type: application/json;charset=utf-8
```

导致post传递的参数格式是Request Payload格式
![image-20200526141509740](/Users/tanlianghao/Library/Application Support/typora-user-images/image-20200526141509740.png)

解决的方法：

```javascript
// 使用qs模块对参数进行序列化
const deviceInfo = JSON.stringify(mteeInfo);
      const data = qs.stringify({ deviceInfo }, { indices: false });
      axios.post('/h5/ajax/DeviceAjax/reportDeviceInfoBySid', data, {
        headers: {
          actk: cookie.get('actks')
        }
      });
// 使用浏览器的API new URLSearchParams(),兼容性不包括所有浏览器。
const params = new URLSearchParams();
params.append('param1', 'value1');
params.append('param2', 'value2');
axios.post('/foo', params);
```

参考文献：[axios post参数问题](https://github.com/axios/axios#using-applicationx-www-form-urlencoded-format)

### 2020-05-27

1、react中的fiber算法。能把任务分片、划分优先级，对线程的抢占式调度。
2、react中的hook为什么不能放在if等条件判断语句中调用。原因在于不能保证调用的顺序。

```javascript
// 在react机制中每次调用hook的都会执行以下的操作来保证对应上各自的hooks
在内部会存在链表。hooks是一个链表数据结构。有一个链表的头部firstWorkInProcessHook,同时还有一个workInProcessHook。初始化的是两者都指向null，后面顺序调用hook，firstWorkInProcessHook永远指向第一个hook不变，workInProcessHook永远指向当前活动的hooks。再次更新的时候workInProcessHook指向firstWorkInProcessHook
```

3、在使用chrome-devtool工具的时候，network-waterflow表示加载资源的时间。其中默认是按发起请求的时间来排序，所以越靠左端的请求越早被发送出去，另外waterflow有两条线，蓝色的是DOMContentLoaded事件触发，红色的是Load事件触发的。
4、react可以使用shouldComponentUpdate判断props和state的变化返回false/true来决定是否需要重新渲染。react.pureComponent只能用来浅比较数据。如果是需要对复杂数据比较，可以重新生成新的对象（Object.assign）或者数组（concat）。
5、super作为关键字，可以用来调用父类的构造函数、父类的静态方法。
6、react生命周期图示
![image-20200527172641491](/Users/tanlianghao/Library/Application Support/typora-user-images/image-20200527172641491.png)

### 2020-05-28

1、script的defer、async都是可以异步下载js文件，defer会先下载好，等DOMContentLoaded执行完再执行js文件，async异步下载完成之后就开始执行代码。
2、页面跳转的时候发起的请求，会不执行，在页面卸载的时候会清除掉其行为。ajax请求中页面卸载，请求中断。
3、相对路径/绝对路径的区别；

```javascript
// 绝对路径，在作为ajax的请求路径的时候，会主动把window.location.origin域名添加在前面
'/h5/ajax/DeviceAjax/reportDeviceInfoBySid?deviceInfo='
// 相对路径，会拿origin+path来作为前缀添加到前面。
'h5/ajax/DeviceAjax/reportDeviceInfoBySid?deviceInfo='

```

4、在使用img.src=xxx来发起请求的时候，后面带的参数需要通过encodeURIComponent(xxx)来进行转换，不然会出现参数被截断的情况。

### 2020-05-29

1、react SSR渲染常使用ReactDOM.hydrate，其作用是在初次渲染的时候复用原本已经存在的DOM结构。这样在做SSR的是客户端就能直接执行绑定事件。
2、node作为中间层的好处，客户端跟服务端直连的情况，由于后端出于性能考虑，返回给前端的接口数据，不一定是前端需要的，需要前端在客户端进一步处理，影响用户体验。

### 2020-06-02

1、js代码的运行在栈内存中，堆内存只是用来存储引用数据类型。

```javascript
a++ ==> Number(a) + 1 // 默认是转换成数字再做加法运算。
```

2、react组件瀑布流，采用的是通过计算两侧的高度，对元素设置左右浮动来实现。

```javascript
var lheight = 0, rheight = 0;
var cls;
if (lheight > rheight) {
  cls = 'float-right';
  rheight += ele.clientHeight;
} else {
  cls = 'float-left';
  lheight += ele.clientHeight
}
```

### 2020-06-03

1、require.resolve()用来获取被引用模块的绝对路径。
2、HMR源码图解
![img](https://user-gold-cdn.xitu.io/2019/12/1/16ec13499800dfce?imageslim)

3、tree-shaking：webpack的去除死代码（未被引用的代码）优化措施。首先需要在package.json 通过sideEffects通知webpack的compiler，被引用的代码中必须是无副作用，除了exports、import之外，没有其他代码运行。最后需要一个插件来清除被webpack标识无用代码。

### 2020-06-04

1、webpack.optimization.splitChunks.cacheGroups.[groupsName].reuseExistingChunk: Boolean，是否重用模块。
2、webpack的dll打包方案，第一次会把指定的文件打包后进行缓存，之后在打包的是如果遇到这些文件，则直接获取缓存好的文件，加快打包的速度。
![image-20200604192639390](/Users/tanlianghao/Library/Application Support/typora-user-images/image-20200604192639390.png)

3、动态导入import()在webpack使用导入commonJS模块的时候，导入的是是default上的值。

### 2020-06-05

1、webpack.output.library同libraryTarget 一起使用，libraryTarget导出的包按什么模块语法。commonJS、amd、umd等，library是导出的变量。
2、webpack.output.filename如果需要使用chunkhash变量来生成hash值，则不能使用webpack的自带HMR插件。
![image-20200605101845689](/Users/tanlianghao/Library/Application Support/typora-user-images/image-20200605101845689.png)

3、从输入URL到页面呈现的过程，如下图，会先查看cache --> DNS解析 --> TCP链接 --> request/response -->dom解析 --> 渲染。
![img](https://user-gold-cdn.xitu.io/2017/3/4/85437b8610f578d65c12360ca57b8989?imageslim)

4、算法归类

```javascript
// 冒泡算法，采用的是单次循环内，前后对比，大的往后冒泡，下次循环不对比已拍好数。
for (let i = 0; i < arr.length; i++){
  for (let j = 0; j < arr.length - i; j++) {
    if (arr[j] > arr[j+1]) {
      let val = arr[j+1];
      arr[j+1] = arr[j];
      arr[j] = val;
    }
  }
}
// 选择排序，初始数组中选择最大的值存放到新的有序数组中，经过n次的选择，得到最后排序的数组
const arr = [1,3,2,5,8,7,6,9,4];
const newArr = [];
let len = arr.length;
while(len) {
  const maxNumber = Math.max(...arr);
  const idx = arr.indexOf(maxNumber);
  len = arr.length;
  newArr.push(maxNumber);
}
// 插入排序，同一个数组，选一个元素a作为基础对比，后续拿其他项b同其对比，如果a>b，a往后移动一格，b继续对比其他项。
for (let i = 1; i < array.length; i++) {
  const item = array[i];
  let j = i - 1;
  while(j >= 0, array[j] > item) {
    array[j + 1] = array[j];
    j--;
  }
  array[j + 1] = item;
}
// 归并排序，把数组切分成左右两个数组，且利用递归重复切割直到最后切分后的数组length < 2，然后利用左右元素对比
const array = [3,44,38,5,47,15];
function splitArray(arr) {
  const len = arr.length;
    return arr;
  }
  const averageNum = Math.floor(len / 2);
  const leftArr = arr.slice(0, averageNum);
  const rightArr = arr.slice(averageNum);
// 递归
  return merge(splitArray(leftArr), splitArray(rightArr));
}
function merge(left, right) {
  const result = [];
  // shift方法会删除第一个元素
    if (left[0] > right[0]) {
      result.push(right.shift());
    } else {
      result.push(left.shift());
    }
  }
  while (left.length) {
    result.push(left.shift())
  }
  while (right.length) {
    result.push(right.shift());
  }
  return result;
}
// 快速排序，跟归并类似，只是在选择基准的时候不同。重点还是在于递归函数的返回值
function quickHanle(array) {
  var len = array.length;
  if (len < 2) {
    return array;
  };
  var leftArr = [];
  var rightArr = [];
  var averNumber = array.splice(Math.floor(array.length / 2), 1)[0];
  var i = 0;
  for (i; i < array.length; i++) {
    var item = array[i];
    if (item < averNumber) {
      leftArr.push(item);
    } else {
      rightArr.push(item);
    }
  }
  return quickHanle(leftArr).concat([averNumber], quickHanle(rightArr));
}
```

### 2020-06-08

1、http传递定长/不定长的方式。定长会在响应头中增加content-length字段，浏览器根据该字段来确保接受的数据完整性；不定长会在响应头增加transfer-encoding: chunked，该字段设置后浏览器会忽略content-length字段。
2、http传输队头堵塞可以通过并发请求，和通过 对不同资源使用多个不同的域名来增加并发量。
3、cookie的几个大属性。expires、max-age过期时间；domain、path作用域；httpOnly、Secure、sameSite安全性。
4、http代理。主要的作用：负载均衡，提供缓存文件，对非法ip进行拦截等。代理在请求-响应中通过via来表明身份。X-Forwarded-For获取请求方的ip，X-real-IP始终获取客户端ip，X-Forwarded-For会引起请求ip一直在变动，而在https中是不允许修改http头信息。
5、https/2.0新增多路复用+头部压缩。

### 2020-06-09

1、exports/module.exports的区别，require()导入的是module.exports指向的对象Obj，而exports是对Obj的引用。同var a = {};var b = a;是一个道理。

```javascript
exports = module.exports = something;
var module.exports = something;
exports = module.exports;
// 上面的代码，如果不使用exports = module.exports。导致的结果就是exports指向的是原来module.exports指向的对象，这样就跟module.exports断开了联系。
```

### 2020-06-10

1、express源码，中间件跟程序处理函数都会按代码书写顺序存放到this.stack对象中（堆），之后当请求到达时，会循环匹配堆中的path是否匹配，再指向匹配上的中间件跟处理程序。
2、V8垃圾回收机制在堆中的表现，堆中的内存会分为新生代/老生代两种，回收方法也不一样，新生代中会平均分成两个。一个闲置一个使用，在回收的时候会把存活的对象移动到闲置的分组上面，这样的原因是对象的分别内存是连续的，新生代采用的是Scavenge算法，解决了内存碎片的问题。

### 2020-06-11

1、javascript代码在V8中的运行情况，首先会把js通过词法/语法分析转换成AST，AST ==> 字节码；字节码通过V8的解释器执行代码，遇到重复代码标记为热点代码，热点代码会被编译器编译成机械码。
2、node爬虫图片的时候，通过http/https发起请求，cheerio把爬到的页面转换成html，并可以使用jquery的方式来获取对应的属性。在通过http访问图片链接的时候需要把response转化成二进制binary，写入的时候也需要指明编码方式。

### 2020-06-17

1、node.js的构成，javascript API层、node.js Binding层（把c++接口转化成javascript api）、chrome V8、libuv（线程池+事件循环）。V8引擎执行代码，遇到异步操作，交给线程池具体执行代码，事件循环执行事件队列中的事件处理函数。
2、constructor作为prototype上的一个属性，如果是指单纯的把构造函数的原型指向到某个实例，会导致构造函数也一起被改变。
3、原型链跟继承。使用原型链会存在问题，一个是如果原型上的存在对象属性，一个实例修改之后会影响到其他的实例。另一个是不能向父类传递参数。原有的几个继承方式，大部分都不会继承到父类构造函数的属性。
4、new操作符内部实现的几个步骤，首先会生成一个新的对象b，并且这个对象的原型会指向传入的构造函数的原型，然后会执行构造函数，此时的构造函数执行this指向到内部定义的res上。如果构造函数返回的是对象数据类型，则最后返回这个返回值对象，如果没有返回或者返回的是原始数据类型，则最后返回的是新创建的对象b。
5、闭包：在当前的作用域中保持着对外部作用域的引用。能读取其他函数内部变量的函数。
6、扩张运算符`...`内部通过for...of实现。Set类型是不重复的类数组数据结构，weakSet参数只能是对象，且垃圾回收机制不考虑其内的引用次数。会被直接回收掉。

### 2020-06-20

###### 1、`__dirname`：指的是被执行文件当前的文件目录位置；__filename：被执行文件的目录路径，待扩展名；process.cwd()：执行node程序的目录路径。

2、webpack.output.publicPath指定的是，在访问资源的时候会路径链接上会带上publicPath指定的值，是相对在node程序中指定的静态资源中去查找的，比如express.static('./')；这样就是相对在node执行目录下去查找publicPath指定的文件路径。
3、socket.io不是websocket的实现，socket.io在实现通信的时候会用到websocket，但socket.io中增加了很多元数据，导致这两者不能互相连接上对方的服务。

### 2020-06-22

1、tree-shaking：基于es6的静态引用机制（import/export）实现。对指定无副作用的文件去除未被引用的代码，可以通过package.json中的sideEffects或者webpack配置中的module.rules来配置。结合js压缩工具实现打包后的文件不包括死代码。
2、HMR（热替换）：通过webpack-dev-server跟webpack之间的交互。webpack-dev-server/client，通过websocket同webpack-dev-middle通信。开发过程中打包会存在内存中。webpack的很多loader都实现了HMR技术，比如style-loader
3、对应聊聊基础工程的实现。
![img](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/8736/1567145714316-9a66b862-ba25-4d9e-9848-4c26bfaebc8f.png)

### 2020-06-23

1、JSON.parse通过eval函数来实现。
2、Function.length表示函数形参的个数，arguments指的是实参的个数。
3、XSS：跨站脚本攻击，通过注入脚本、引导用户来实现攻击。CSRF：跨站请求伪造，劫持用户cookie，伪造成正常的用户。有效措施：验证码、token、请求头中的Referer来源。
4、箭头函数中this的指向是定义时决定的对象，而不是运行时指定的对象。对象没有单独的作用域。尾调用，在函数最后调用函数且对外部的参数不能有引用，不然外部的调用栈不会被去掉。

```javascript
function handle(n) {
  let m = 1;
  return handle(m);
}
// this 指向
const aa = {
  b: () => {
    console.log(this)
  }
}
//等价于
const _this = void(0);
const aa = {
  b: function() {
	console.log(_this);
  }
}
```

递归调用会在占用很多内存，存在大量调用栈，而尾递归，则只保留一个调用栈。
5、const声明的变量不能改变，指的是变量的内存地址不能变，对对象类型的数据，因为赋值只是对象的指针，所有是可以改变对象的值。

### 2020-07-01

1、CSS加载不会阻止DOM的解析，但会阻止DOM的渲染。从渲染过程图中可以发现，DOM Tree 跟 CSSOM Tree 是并行执行的，所以对DOM解析没影响，而DOM渲染是需要两者生成render Tree，所以会有影响。
![image-20200701095540593](/Users/tanlianghao/Library/Application Support/typora-user-images/image-20200701095540593.png)

2、px（绝对长度单位）、em（相对长度单位）总是相对于父元素来设置，rem（相对长度单位）相对于root的单位长度。

### 2020-07-02

1、jquery插件的实现规范，jquery提供了接口，通过使用juqery.fn.extend来实现自定义jquery插件。
2、jquery怎么实现dom节点遍历，调用方式是$('span')，通过document.getElementByTagName(selector)获取元素，然后通过返回数组的形式实现。
3、node中如何查询内存溢出。暂时不理解。
4、react中的diff算法实现原理。通过深度优先遍历查找两个虚拟dom之间的差异，并存储起来，之后patch到实际的dom上去。
5、集群部署，在重启的阶段，如果用户正好发送了请求过来，如果保证能正确的返回用户请求数据。采用平滑重启，node cluster采用重启worker进程，重启一个woker进程之后，再继续其他的worker进程。
6、服务器挂掉怎么自动扩容。cluster方式，挂掉woker进程之后，自动重启另外一个woker进程。
7、react的全局store怎么实现多页面直接的数据共享。localStorage存起来
8、移动端不同分辨率屏怎么实现物理像素1px。可以使用dpr = window.devicePixelRatio属性来获取设备的像素比，然后采用媒体查询media ，另外可以采用阴影来实现。

```css
@media screen and (-webkit-min-device-pixel-ratio: 2) {
    .border { border: 0.5px solid #999 }
}
```

9、http3。基于UDP协议。
10、深度优先遍历和广度优先遍历。

### 2020-07-06

1、浏览器运行原理，chrome包括的进程：浏览器进程（负责子进程的管理、用户交互）、渲染进程（负责解析html，css，js）V8引擎在这个进程中，沙箱隔离、网络进程（负责页面网络资源加载）、GPU进程（负责repaint）、插件进程（负责管理chrome插件，插件易崩溃，所以单独隔离开）。
2、es6模块知识点，暂时性死区
3、react函数式组件怎么实现shouldcomponentUpdate，主要是通过React.memo高阶组件来包装，对props进行浅对比，如果需要控制对比逻辑，可以在第二个参数传入compire函数，props是否相等、
4、PV跟UV，pv值指的是一天内用户浏览网站的总次数，同一个用户多次刷新多次计算，UV值指的是同一个ip访问网站，只算一次uv值。
5、node的高并发实现。通过
6、async的实现原理

```javascript
async function aa() {}
// 等价于
function aa() {
  return spanw(function* () {
    ....
  })
}
function spanw(genFn) {
  return new Promise(function(resolve, reject) {
		let gen = genFn();
    function step(nextF) {
			let next;
      try {
				next = nextF();
      } catch(e) {
				return reject(e);
      }
      Promise.resolve(next.value).then(function(v) {
        step(function() { return gen.next(v); });
      }, function(e) {
        step(function() { return gen.throw(e); });
      });
    }
    step(function() {
      return gen.next(undefined)
    })
  })
}
```

7、node/浏览器中的事件循环，宏任务跟微任务执行区别。node中的事件循环存在着timer、polling、checked等阶段，每个阶段后都有一个微任务队列，当前阶段的宏任务执行完成之后，执行清空对应阶段的微任务队列，再进入下一个阶段，而浏览器中宏任务执行完成，执行微任务队列。比如两个延时器任务，在node中是一起执行完，而在浏览器中两个延时器任务之间需要执行微任务。

### 2020-07-10

1、rem，lib-flexible实现原理，首先根据dpr设置body的字体大小，然后根据clientwidth/10来设置document文档的根字体大小，在sass中设置pxTo2rem函数，设置基础basefont值的大小，对应的元素px/basefont * 1rem 得到的就是rem单位，而rem是相对于根字体font-size的大小，所以根字体大小变化从而引起1rem的对应px值变化。lib-flexible开始设置body的字体是12 * dpr 是为了子元素继承body的字体大小。

### 2020-07-24

1、memo、useMemo、useCallback之间的区别。
memo跟pureComponent功能一样，都是为了减少组件的重复渲染。useMemo返回的是memoized值，而useCallback返回的是memorized函数，两者的第二个参数区别，useMemo第二个参数不会传递给第一个参数的函数中，而useCallback参数会被传递到第一个参数的函数中。

### 2020-08-20

1、flutter 中的路由中的作用，App不像web页面，可以直接通过输入路由来访问页面，在App中首先进去看到的必定为首页，这也导致了不会出现直接通过路由来访问页面的情况，通过MaterialApp来定义的应用，通过onGenerateRoute来定义的路由更多是为了之后在app中通过调用Navigation.of(context).pushNamed来调用到onGenerateRoute方法。
2、接入oss